\documentclass[11pt]{letter}
\usepackage{amsmath}
\usepackage{xepersian}
\settextfont{B Zar}
\renewcommand{\baselinestretch}{1.3} 
\begin{document}
	\begin{center}
		{\huge آرایه پویا با طعم فیبوناچی}\\
		{ پویا آقاحسینی ۹۵۱۳۰۰۶}
	\end{center}
	\begin{RTL}
	برای دنباله ای از عملیات میخواهیم بررسی کنیم که عملیات های 
	\lr{Add}
	و
	\lr{Remove}
	در 
	\lr{O(1)}
	به صورت سرشکن انجام میشود. \\
	ایده اثبات مشابه ایده اثبات برای عملیات های
	\lr{ArrayList}
	در کتاب 
	\lr{OpenDataStructures}
	است که برای هر باری که آرایه جدید می سازیم حداقل تعداد 
	\lr{Add}
	و
	\lr{Remove}
	ها را از آخرین باری که آرایه را 
	\lr{Resize}
	کردیم بررسی میکنیم. \\
	ابتدا دو حالت 
	\lr{Add}
	و
	\lr{Remove}
	را بررسی میکنیم و سپس مجموع تعداد 
	\lr{Add}
	و
	\lr{Remove}
	ها را بررسی میکنیم که به صورت سرشکن چگونه میشود.\\
	\\
{\LARGE حالت اول:}\\
	در حالتی که 
	\lr{Add}
	کردیم و مجبور هستیم 
	\lr{Resize}
	کنیم، طول آرایه
	\lr{ $F_{k}$ }
	و تعداد عناصر 
	\lr{ $F_{k-1}$ }
	شده است. مرتبه قبلی که 
		\lr{Resize}
		کردیم،
			\lr{ $F_{k-2}$ }
			عنصر داشتیم و برای اینکه با کمترین عملیات به این وضعیت برسیم باید فقط 
			\lr{Add}
			میکردیم پس باید حداقل 
				\lr{ $F_{k-1} - F_{k-2} = F_{k-3}$ }
				بار 
				\lr{Add}
				را صدا بزنیم.\\
				\\
				{\LARGE حالت دوم:}\\
				در حالتی که 
				\lr{Remove}
				کردیم و مجبور هستیم 
				\lr{Resize}
				کنیم، طول آرایه
				\lr{ $F_{k}$ }
				و تعداد عناصر 
				\lr{ $F_{k-3}$ }
				شده است. مرتبه قبلی که 
				\lr{Resize}
				کردیم،
				\lr{ $F_{k-2}$ }
				عنصر داشتیم و برای اینکه با کمترین عملیات به این وضعیت برسیم باید فقط 
				\lr{Remove}
				میکردیم پس باید حداقل 
				\lr{ $F_{k-2} - F_{k-3} = F_{k-4}$ }
				بار 
				\lr{Remove}
				را صدا بزنیم.
				\\
				\\
				تا اینجا نشان دادیم که هر بار که 
				\lr{Resize}
				میکنیم تعداد 
				\lr{Add}
				و
				\lr{Remove}
				ها از 
				\lr{Resize}
				قبلی به ترتیب حداقل 
								\lr{ $F_{k-3}$ }
								و
								\lr{ $F_{k-4}$ }
								است.
								 میخواهیم بگویم که برای دنباله ای 
								\lr{$m$}
								تایی از عملیات
									\lr{Add}
								و
								\lr{Remove}
								زمان کلی همه 
									\lr{Resize}
									ها 
									\lr{O(m)}
								میشود و در نتیجه هر عملیات را 
								\lr{O(1)}
								نتیجه میدهد.
								\\ برای راحتی اثبات زمان 
																\lr{ $F_{k-4}$ }
																برای 
																\lr{Remove}
																را مانند 
			\lr{Add}
			همان 
				\lr{ $F_{k-3}$ }
			در نظر میگیریم.\\
			حال برای هر مرحله که ریسایز صدا زده میشود حداقل عملیات های
							\lr{Add}
			و
			\lr{Remove}
			 آن را جمع میزنیم که میشود :
			\lr{$$\sum_{i=1}^{r} F_{i-3} \leq m $$}		
			که هر
						\lr{$F_{i-3}$}
			میتواند یک عدد فیبوناچی دلخواهی در مرحله 
			\lr{i}
			 امین ریسایز باشد. دقت شود که منظور عدد فیبوناچی  
			 						\lr{${i-3}$}
			 						نیست چون منفی میشود بلکه منظور حداقل تعداد عملیات ها بین دو ریسایز متوالی است که مقدار آن حداقل 1 است.
			 						\\
			حال میخواهیم 
									\lr{$F_{i-3}$}
									ها را به صورت 
									\lr{$F_{i-1}$}
			بنویسیم چون زمانی است که برای کپی کردن عناصر صرف میشود(زمانی که برای 
			\lr{Remove}
			صرف میشود اینجا نیز کمتر است و ما آن را با 
			\lr{Add}
			برابر میگیریم).
\lr{$$F_{k-1} = F_{k-2}+F_{k-3} = 2F_{k-3} + F_{k-4} \leq 3F_{k-3} $$}
پس داریم 
\lr{$$F_{k-1} \leq 3F_{k-3} $$}
\lr{$$\sum_{i=1}^{r} F_{i-3} \leq m  \Rightarrow \sum_{i=1}^{r} 3F_{i-3} \leq 3m \Rightarrow \sum_{i=1}^{r} F_{i-1} \leq \sum_{i=1}^{r} 3F_{i-3} \leq 3m$$}
			
			پس زمان کپی کردن عناصر برای هر بار صدا زدن ریسایز به ازای 
			\lr{$m$}
		عملیات نیز بدین صورت بدست می‌آید:
\lr{$$ \sum_{i=1}^{r} Elements(i) = \sum_{i=1}^{r} F_{i-1} \leq 3m = O(m)$$}		
			که در مجموع 
						\lr{$m$}
						عملیات 
							\lr{Add}
			و
			\lr{Remove}
						در 
						\lr{O(m)}
						اجرا میشود
					و به صورت سرشکن هر عملیات در 
					\lr{O(1)}
					صورت میپذیرد.
				\end{RTL}
\end{document}